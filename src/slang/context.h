#ifndef SLANG_CONTEXT_H
#define SLANG_CONTEXT_H

#include <functional>

#include "slang/types.h"
#include "slang/sema.h"
#include "slang/environment.h"

namespace slang {

/// Helper class to setup a context.
class Context {
public:
    typedef std::function<void (const PrimType*, ast::PrimType::Prim)> PrimTypeFn;
    typedef std::function<void (Sema&, PrimTypeFn)> GenTypeFn;

    Context(Sema& sema)
        : sema_(sema), env_(*sema.builtin_env())
    {}

    Context(Sema& sema, Environment& env)
        : sema_(sema), env_(env)
    {}

    /// Registers a function in the environment, given a list of definitions and a list of signatures.
    void register_function(const std::string& name, Symbol::DefMap&& defs, OverloadedFunctionType::SignatureList& signs);
    /// Registers an unary function in the environment.
    void register_unary(const std::string& name, GenTypeFn f);
    /// Registers a binary function with two different argument types in the environment.
    void register_binary(const std::string& name, GenTypeFn f);
    /// Registers a binary function with two different argument types in the environment.
    void register_binary(const std::string& name, GenTypeFn f, GenTypeFn g);

    /// Calls the given function with the types generated by genType.
    static void gentype(Sema& sema, PrimTypeFn f);
    /// Calls the given function with the types generated by genIType.
    static void genitype(Sema& sema, PrimTypeFn f);
    /// Calls the given function with the types generated by genUType.
    static void genutype(Sema& sema, PrimTypeFn f);
    /// Calls the given function with the types generated by genBType.
    static void genbtype(Sema& sema, PrimTypeFn f);
    /// Calls the given function with the types generated by genDType.
    static void gendtype(Sema& sema, PrimTypeFn f);

    /// Register all the builtin functions.
    void register_all() {
        register_trigonometric();
        register_exponential();
        register_common();
    }

    /// Register trigonometric functions.
    void register_trigonometric() {
        register_radians();
        register_degrees();

        register_sin();
        register_cos();
        register_tan();

        register_asin();
        register_acos();
        register_atan();

        register_cosh();
        register_sinh();
        register_tanh();

        register_acosh();
        register_asinh();
        register_atanh();
    }

    /// Register exponential functions.
    void register_exponential() {
        register_pow();
        register_exp();

        register_log();
        register_exp2();
        register_log2();

        register_sqrt();
        register_inversesqrt();
    }

    /// Register common functions.
    void register_common() {
        register_abs();
        register_sign();

        register_floor();
        register_trunc();
        register_round();
        register_roundeven();
        register_ceil();
        register_fract();
    }

    void register_radians() { register_unary("radians", gentype); }
    void register_degrees() { register_unary("degrees", gentype); }

    void register_sin() { register_unary("sin", gentype); }
    void register_cos() { register_unary("cos", gentype); }
    void register_tan() { register_unary("tan", gentype); }

    void register_asin() { register_unary("asin", gentype); }
    void register_acos() { register_unary("acos", gentype); }
    void register_atan() {
        register_unary("atan", gentype);
        register_binary("atan", gentype);
    }

    void register_cosh() { register_unary("cosh", gentype); }
    void register_sinh() { register_unary("sinh", gentype); }
    void register_tanh() { register_unary("tanh", gentype); }

    void register_acosh() { register_unary("acosh", gentype); }
    void register_asinh() { register_unary("asinh", gentype); }
    void register_atanh() { register_unary("atanh", gentype); }

    void register_pow() { register_binary("pow", gentype); }

    void register_exp() { register_unary("exp", gentype); }
    void register_log() { register_unary("log", gentype); }
    void register_exp2() { register_unary("exp2", gentype); }
    void register_log2() { register_unary("log2", gentype); }

    void register_sqrt() {
        register_unary("sqrt", gentype);
        register_unary("sqrt", gendtype);
    }

    void register_inversesqrt() {
        register_unary("inversesqrt", gentype);
        register_unary("inversesqrt", gendtype);
    }

    void register_abs() {
        register_unary("abs", gentype);
        register_unary("abs", genitype);
        register_unary("abs", gendtype);
    }

    void register_sign() {
        register_unary("sign", gentype);
        register_unary("sign", genitype);
        register_unary("sign", gendtype);
    }

    void register_floor() {
        register_unary("floor", gentype);
        register_unary("floor", gendtype);
    }

    void register_trunc() {
        register_unary("trunc", gentype);
        register_unary("trunc", gendtype);
    }

    void register_round() {
        register_unary("round", gentype);
        register_unary("round", gendtype);
    }

    void register_roundeven() {
        register_unary("roundEven", gentype);
        register_unary("roundEven", gendtype);
    }

    void register_ceil() {
        register_unary("ceil", gentype);
        register_unary("ceil", gendtype);
    }

    void register_fract() {
        register_unary("fract", gentype);
        register_unary("fract", gendtype);
    }

private:
    ast::Arg* new_argument(const Type* type, ast::PrimType::Prim prim);

    Sema& sema_;
    Environment& env_;
};

} // namespace slang

#endif // SLANG_CONTEXT_H

